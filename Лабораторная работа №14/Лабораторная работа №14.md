# **РОCСИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
## Факультет физико-математических и естественных наук 
## Кафедра прикладной информатики и теории вероятностей 

## ОТЧЕТ
## ПО ЛАБОРАТОРНОЙ РАБОТЕ № 14

### *дисциплина: Операционные системы*

Студент: Губина Ольга Вячеславовна 

Группа: НПИбд-01-20

Преподаватель: Велиева Татьяна Рефатовна

МОСКВА 

2021 г.

---

### **Цель работы:**

Приобрести простейшие навыки разработки, анализа, тестирования и отладки
приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

### **Задачи:**

1. Научиться выполнять компиляцию по средствам командной строки;
2. Освоить отладчик GDB;
3. Научиться анализировать исходные коды.

### **Теоретическое введение:**

***Этапы разработки приложений***

- планирование, включающее сбор и анализ требований к функционалу и другим
характеристикам разрабатываемого приложения;

- проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования;

- непосредственная разработка приложения:
    - кодирование — по сути создание исходного текста программы (возможно в
нескольких вариантах);
    - анализ разработанного кода;
    - сборка, компиляция и разработка исполняемого модуля;
    - тестирование и отладка, сохранение произведённых изменений;

- документирование.

***Компиляция исходного текста и построение исполняемого
файла***

Для компиляции, например, файла ```main.c``` используют команду:

```
gcc -c main.c
```

Если требуется получить исполняемый файл с определённым именем (например, hello), то требуется воспользоваться опцией -o и в качестве параметра задать
имя создаваемого файла:

```
gcc -o hello main.c
```

С прочими опциями компилятора ```gcc``` можно ознакомиться в статье *"Опции компиляторов"*[[1]]().

Для сборки разрабатываемого приложения и собственно компиляции полезно
воспользоваться утилитой ```make```. Она позволяет автоматизировать процесс преобразования файлов программы из одной формы в другую, отслеживает взаимосвязи
между файлами.

***Тестирование и отладка***

Для использования отладчика GDB необходимо скомпилировать анализируемый код программы таким образом, чтобы отладочная информация содержалась в результирующем бинарном файле. Для этого следует воспользоваться опцией -g компилятора
gcc:

```
gcc -c file.c -g
```

После этого для начала работы с gdb необходимо в командной строке ввести одноимённую команду, указав в качестве аргумента анализируемый бинарный файл:

```
gdb file.o
```

Затем можно использовать по мере необходимости различные команды gdb.

***Анализ исходного текста программы***

Для анализа кода программы example.c следует выполнить следующую команду:

```
splint example.c
```

***В ходе работы*** над понадобится установить утилиту splint на Centos 7, поэтому воспользуемся статьей *"УСТАНОВКА ПАКЕТОВ В CENTOS 7"*[[2]]().

Все коды, которые использовадись во время выполнения работы были взяты из *Лабораторной работы №14*[[3]]().

### Выполнение работы:

1, 2. В домашнем каталоге нам нужно создать подкаталог ~/work/os/lab_prog.

Каталоги work ии os уже были созданы во время выполенения предыдущих лабораторных работ. Поэтому просто переходим в каталог ```~/work/os``` и создаем в нем подкаталог lab_prog - ```mkdir lab_prog``` (*рисунок 1*). Перейдем в него командой cd lab_prog. Создадим в нём файлы: calculate.h, calculate.c, main.c с помощью текстового редактора ```emacs``` (*рисунок 1*).
Это будет примитивнейший калькулятор.

![](https://sun9-15.userapi.com/impg/aphPUgbJNzRoRZ313DpSooevqtmwrS-yzsDBTg/nREs4hYujsQ.jpg?size=527x194&quality=96&sign=6eb20e81edd2764d444a7fe1557d0e18&type=album)

    рисунок 1: создание подкаталога ~/work/os/lab_prog и файлов calculate.h, calculate.c, main.c 

В файл calculate.h вводим код на языке программирования С, предоставленный в материалах к ЛР №14 (*рсиунок 2*)

![](https://sun9-52.userapi.com/impg/dXYFyhw70Z8JFHvvwuW57TIqgHab0WUCwjt-bQ/5YEv8G9cbrA.jpg?size=755x298&quality=96&sign=7326f20c0975da9b77328dff7d9bbbc8&type=album)

    рисунок 2: файл calculate.h

То же делаем с файлами calculate.c (*рисунок 3*) и main.c (*рисунок 4*).

![](https://sun9-52.userapi.com/impg/9GTH7RD_67d4mxZX2dVq3uGtHC6eETmRNzoBhQ/8DbSchYSWnM.jpg?size=756x647&quality=96&sign=609529ef2f527f824d1b09bc7326e210&type=album)

    рисунок 3: файл calculate.c

![](https://sun9-75.userapi.com/impg/tujBAsIMSWQwc2dH_LCnARZdw8DD6aNqg3Gbgg/jGWj9gnGnhE.jpg?size=757x491&quality=96&sign=e79bfb97f9f8dca0318021b75e7554c5&type=album)

    рисунок 4: файл main.c

3, 4. Теперь выполним компиляцию программы посредством gcc, ввода следующие команды (*рисунок 5*):

```
gcc -c calculate.c
gcc -c main.c
gcc calculate.o main.o -o calcul -lm
```

![](https://sun9-18.userapi.com/impg/f6HbEkF0CzvE6gAnHOYIDCp29lPJxAsR8jUODA/fv2uYT3W2Dc.jpg?size=659x94&quality=96&sign=b5e8376b64825bb482fd10e5cc66f940&type=album)

    рисунок 5: компиляция прогарммы посредством gcc

Видим, что система не выдает нам сообщений об ошибках, следовательно код написан правильно, и нам нечего исправлять.

5. Создадим Makefile, который будет расположен в каталоге lab_prog, поскольку makefile должен находиться в том же месте, где и проект, связанный с ним. Создаем файл с помощью редактора emacs и вводим в него предложенный код файла из лабораторной работы (*рисунок 6*).

![](https://sun9-7.userapi.com/impg/l5-ItNp93vQcGWcf3aNmVUe2ClAqVLGv_vYXKA/5thc4FkVaJA.jpg?size=758x574&quality=96&sign=d2ddc68d6130c3d4f2aa1040d7bec266&type=album)

    рисунок 6: создание Makefile

6. С помощью gdb выполним отладку программы calcul. Для использования GDB нам необходимо сначала скомпилировать анализируемый код программы таким образом, чтобы отладочная информация содержалась в результирующем бинарном файле (*рисунок 7*). Для этого следует воспользоваться опцией -g компилятора
gcc, тогда синтаксис компиляции будет следующим:

```
gcc -c [имя файла] -g
```

![](https://sun9-64.userapi.com/impg/PZu8zBszo7bdmpHNGwV8qyg2yDRslUm11nNIjA/MFGx5kwHf1g.jpg?size=656x72&quality=96&sign=77fa58454bc644adb399f75162dde18e&type=album)

    рисунок 7: компиляция перед запуском GDB

- Запустим отладчик GDB, загрузив в него программу для отладки:
```gdb ./calcul``` (*рисунко 8*).

![](https://sun9-41.userapi.com/impg/lTxevcKlNG9eD1wOz4bLcWehRhGhvr80VybgnA/bTZx1jj2Lqk.jpg?size=722x235&quality=96&sign=264c37b136e5893a4928597e4f34ab12&type=album)

    рисунок 8: запуск отладчика GDB

- Теперь нам нужно запустить программу внутри отладчика. Для этого внутри отладчика введем команду ```run```` (*рисунок 9*).

![](https://sun9-31.userapi.com/impg/k9fQ7uID0XqqNkUARYLrxKcwhMHu6JCyuWGuTA/3nhTTq5ARgk.jpg?size=734x226&quality=96&sign=7e45fad57558a1aba9286cbd44737773&type=album)

    рисунок 9: запуск программы в отладчике

Видим, что программа была успешно запущенна. На ввод нам предлагается ввести какое-либо число (вводим 4), операцию, которая будет производится с ним (в нашем случае это сложение), далее нам предлагается ввести второе слагаемое (5). Результат выделен черным - 9. Программа работает исправно.

- Для постраничного (по 9 строк) просмотра исходного код используем команду ```list``` (*рисунок 10*). Видим, что действительно вывелось 9 строк (4-13).

![](https://sun9-53.userapi.com/impg/361hd-ngG-5IIIkxfxDkDt05L1I9WvtOLUzREw/1uw8dLyjKLU.jpg?size=731x282&quality=96&sign=8bb81d32a6fee6b6538a6b3224a07648&type=album)

    рисунок 10: постраничный вывод list

- Для просмотра строк с 12 по 15 основного файла используем list с параметрами - ```list 12,15``` (*риснуок 11*).

![](https://sun9-7.userapi.com/impg/MCkuCsDgo-t4iAtBTOhk877oL0SDFiO3zPGKCA/nZZ3he2xJkA.jpg?size=736x175&quality=96&sign=aa21aec90217d7f297194cd7d5cc7d0a&type=album)

    рисунок 11: просмотр определенных строк

- Для просмотра определённых строк не основного файла используем list с параметрами: ```list calculate.c:20,29``` (*рисунок 12*).

![](https://sun9-14.userapi.com/impg/Ng_zyE27mlOZin-xTDfkMCvxrs9PgL_WazKgOg/RQ2vJfxp89o.jpg?size=731x284&quality=96&sign=eaa129218b87bec09ef15385e4af5d11&type=album)

    рисунок 12: просмотр определённых строк не основного файла

- Установим точку останова в файле calculate.c на строке номер 21: ```break 21``` (*рисунок 13*).

![](https://sun9-12.userapi.com/impg/WhuTHkPoW70Z7ZVYp1RPESR4n27urRHaLrI9Ew/Yx760c6O4mQ.jpg?size=733x284&quality=96&sign=bd1c85783fab093e75cdef7eddae1d99&type=album)

    рисунок 13: установка точки останова

Видим, что точка была успешно установлена.

- Выведем информацию об имеющихся в проекте точка останова. Для этого введем команду ```info breakpoints``` (*рисунок 14*).

![](https://sun9-23.userapi.com/impg/FarI_sLF6T-9Iomq5co4ViLijvXxrI1QD4MbaQ/1L8j_yoJ1kA.jpg?size=735x158&quality=96&sign=e536529db3dba4a0f77817ac2d2924c8&type=album)

    рисунок 14: информация об имеющихся в проекте точка останова

Можем наблюдать информацию о точке, которую мы только что установили: ее номер, тип, адрес, место установки. 

- Запустим программу внутри отладчика с помощью ```run``` и убедимся, что программа остановится в момент прохождения точки останова (*рисунок 15*). На ввод подаем число 5, в качестве операдии - вычитание. Видим, что программа останавливается на строке 21, куда была установлена точка останова, и дальше не идет.

![](https://sun9-16.userapi.com/impg/2zCJn4xue5DwCMtDlyhMYVKc__gRfakX2eMBqg/tbJFvMRcfR0.jpg?size=733x284&quality=96&sign=d6b6c8b08e5d86094619c2e8fcdead09&type=album)

    рисунок 15: запуск программы с установленной точкой останова

При вводе команды backtrace отладчик выдает следующую информацию:

```
#0 Calculate (Numeral=5, Operation=0x7fffffffdf30 "-")
at calculate.c:21
#1 0x0000000000400b2b in main () at main.c:17
```

Она показывает весь стек вызываемых функций от начала
программы до текущего места.

- Посмотрим, чему равно на этом этапе значение переменной Numeral, введя ```print Numeral``` и сравним ее вывод с результатом вывода ```display Numeral``` (*рисунок 16*).
Видим, что в обоих случаях выводится число 5, что и ожидалось.

![](https://sun9-56.userapi.com/impg/LyvxrBZ__VE93Pazos2PkGVUdJPOIhrpdjTcrQ/JzKGJnVes00.jpg?size=733x158&quality=96&sign=d7469e258981c7fd75a90a4c925559a4&type=album)

    рисунок 16: сравнение вывода print Numeral и display Numeral

- Убираем точки останова. Сначала посмотрим информацию о текущих точках ```info breakpoints```, чтобы узнать номер точки, которую мы собираемся удалить. Далее удаляем ее ```delete 1```, где 1 - номер точки. Снова просматриваем ```info breakpoints```, чтобы убедиться в удлении точки (*рисунок 17*).

![](https://sun9-26.userapi.com/impg/3nhdQ9_7dUTzi2Q3KpSre8KDvlT6CQCdfRoU5w/i5lyecjPiTE.jpg?size=733x230&quality=96&sign=190b6bf2221dcb9902417a1f27fba7ea&type=album)

    рисунок 17: удаление точки останова

Видим по последнему выводу, что точка была успешно удалена.

7. Теперь с помощью утилиты splint нам нужно проанализировать коды файлов calculate.c и main.c. Для этого сначала установим данную утилиту, перейдя в режим суперпользователя ```su``` (*рисунки 18-19*). 

![](https://sun9-40.userapi.com/impg/TSfc1_aPIFUj_qQjFGORrYSqtj2QPbYxR5wYZw/i7WI_XanbCU.jpg?size=734x398&quality=96&sign=c5d2c49b0782dda8eae11cb45ae51809&type=album)

    рисунок 18: установка утилиты splint

![](https://sun9-54.userapi.com/impg/vGiuBrnhEGYJ8YifFqdMLAGBhYLmBcfuqoPh2A/8apQeegjtQw.jpg?size=734x497&quality=96&sign=6ca766f36fe632f228f64a4ec291a4aa&type=album)

    рисунок 19: установка утилиты splint

Выходим из режима суперпользователя и анализируем коды файлов calculate.c (*рисунок 20*) и main.c (*рисунок 21*) через ```splint [имя файла]```.

![](https://sun9-36.userapi.com/impg/JOIDnvArKySvbIR_py3YpwGUQR1W7qpY92D4yw/B6JevJwGwbk.jpg?size=801x783&quality=96&sign=6ab55756f583260dbefdcf157d05568a&type=album)

    рисунок 20: анализ кода calculate.c

![](https://sun9-67.userapi.com/impg/AK9tgFTa6GFvl3BeQpv-oHdD_-yhNNOF8ceDcw/pO743m9jzDM.jpg?size=882x389&quality=96&sign=bbb756dcaabd6baa8892871f78139d98&type=album)

    рисунок 21: анализ кода main.c

Видим, что утилита ```splint``` анализирует программный код, проверяет корректность задания аргументов использованных в программе функций и типов
возвращаемых значений, а также обнаруживает синтаксические и семантические ошибки.

---

## Вывод: 

Приобрела простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

### Библиография:

[1]: [Опции компиляторов](https://parallel.uran.ru/book/export/html/15)

[2]: [УСТАНОВКА ПАКЕТОВ В CENTOS 7](https://losst.ru/ustanovka-paketov-v-centos-7)

[3]: [Лабораторная работа №14](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf)

---

### Контрольные вопросы:

**1. Как получить информацию о возможностях программ gcc, make, gdb и др.?**

Можно воспользоваться справкой man.

**2. Назовите и дайте краткую характеристику основным этапам разработки приложений в UNIX.**

Этапы разработки приложений UNIX:

- создание исходного кода программы;

- сохранение различных вариантов исходного текста;

- анализ исходного текста; Необходимо отслеживать изменения исходного кода, а также при работе более двух программистов над проектом программы нужно, чтобы они не делали изменений кода в одно время.

- компиляция исходного текста и построение исполняемого модуля

- тестирование и отладка;

- сохранение всех изменений, выполняемых при тестировании и отладке.

**3. Что такое суффикс в контексте языка программирования? Приведите примеры использования.**

Суффикс определяет тип компиляции для файла. Суффиксы и префиксы указывают на тип объекта. Например: по суффиксу .c компилятор распознает, что файл должен компилироваться, а по суффиксу .o, что файл является объектным модулем и для получения исполняемой программы необходимо выполнить редактирование связей. Простейший пример командной строки для компиляции программы abcd.c и построения исполняемого модуля abcd имеет вид: gcc -o abcd abcd.c.

**4. Каково основное назначение компилятора языка С в UNIX?**

Сборака команды перед работой и выявление ошибок синтаксиса и семантики.

**5. Для чего предназначена утилита make?**

make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта.

**6. Приведите пример структуры Makefile. Дайте характеристику основным элементам этого файла.

Текст, следующий за точкой с запятой, и все последующие строки, начинающиеся с литеры табуляции, являются командами OC UNIX, которые необходимо выполнить для обновления целевого файла. Таким образом, спецификация взаимосвязей имеет формат:

```
target1 [ target2...]: [:] [dependment1...]
[(tab)commands]
[#commentary]
[(tab)commands]
[#commentary]
```

где # — специфицирует начало комментария; : — последовательность команд ОС UNIX должна содержаться в одной строке make-файла (файла описаний), есть возможность переноса команд, но она считается как одна строка; :: — последовательность команд ОС UNIX может содержаться в нескольких последовательных строках файла описаний.

**7. Назовите основное свойство, присущее всем программам отладки. Что необходимо сделать, чтобы его можно было использовать?**

Все программы отладки позволяют отслеживать состояние программы на любом из этапов ее исполнения. Для того чтобы эту возможность использовать необходимо изучить документацию по использованию определенного отладчика. Понять общие принципы отладки

**8. Назовите и дайте основную характеристику основным командам отладчика gdb.**

- backtrace – выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); иными словами, выводит весь стек функций;

- break – устанавливает точку останова; параметром может быть
номер строки или название функции;

- clear – удаляет все точки останова на текущем уровне стека (то есть в текущей функции);

- continue – продолжает выполнение программы от текущей точки до конца;

- delete – удаляет точку останова или контрольное выражение;

- display – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы;

- finish – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется;

- info breakpoints – выводит список всех имеющихся точек останова;

- info watchpoints – выводит список всех имеющихся контрольных выражений;

- list – выводит исходный код; в качестве параметра передаются
название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки;

- next – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции;

- print – выводит значение какого-либо выражения (выражение передаётся в качестве параметра);

- run – запускает программу на выполнение;

- set – устанавливает новое значение переменной

- step – пошаговое выполнение программы;

- watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;

**9. Опишите по шагам схему отладки программы, которую Вы использовали при выполнении лабораторной работы.**

1. Запуск отладчика
2. Просмотр кода постранично
3. Установка точки сотанова
4. Тест программы путем ввода параметров
5. Снятие точек 

**10. Прокомментируйте реакцию компилятора на синтаксические ошибки в программе при его первом запуске.**

Не сталкивалась с ошибками во время выполнения.

**11. Назовите основные средства, повышающие понимание исходного кода программы.**

- cscope - исследование функций, содержащихся в программе;

- lint - критическая проверка программ, написанных на языке Си.

**12. Каковы основные задачи, решаемые программой splint?**

Утилита ```splint``` анализирует программный код, проверяет корректность задания аргументов использованных в программе функций и типов
возвращаемых значений, а также обнаруживает синтаксические и семантические ошибки.






