# **РОCСИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
## Факультет физико-математических и естественных наук 
## Кафедра прикладной информатики и теории вероятностей 

## ОТЧЕТ
## ПО ЛАБОРАТОРНОЙ РАБОТЕ № 11

### *дисциплина: Операционные системы*

Студент: Губина Ольга Вячеславовна 

Группа: НПИбд-01-20

Преподаватель: Велиева Татьяна Рефатовна

МОСКВА 

2021 г.

---

### **Цель работы:**

Изучить основы программирования в оболочке ОС UNIX/Linux. Научиться писать небольшие командные файлы.

### **Задачи:**

1. Получить навыки работы с основными командами языка bash;
2. Научиться писать небольшие командные файлы;
3. Применить их на практике.

### **Теоретическое введение:**

В данной лабораторной работе нам предстоит научиться писать командные файлы и использовать их на практике. Для этого нам необходимо ознакимиться с некоторой теорией. 

**Командные процессоры (оболочки)**

*Командный процессор* (командная оболочка, интерпретатор команд shell) —
это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. 

В операционных системах типа UNIX/Linux наиболее часто
используются следующие реализации командных оболочек:

- оболочка Борна (Bourne shell или sh) — стандартная командная оболочка
UNIX/Linux, содержащая базовый, но при этом полный набор функций;

- С-оболочка (или csh) — надстройка на оболочкой Борна, использующая Сподобный синтаксис команд с возможностью сохранения истории выполнения
команд;

- оболочка Корна (или ksh) — напоминает оболочку С, но операторы управления
программой совместимы с операторами оболочки Борна;

- BASH — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software
Foundation).

*POSIX* (Portable Operating System Interface for Computer Environments) — набор
стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ.

Стандарты POSIX разработаны комитетом IEEE (Institute of Electrical and
Electronics Engineers) для обеспечения совместимости различных UNIX/Linuxподобных операционных систем и переносимости прикладных программ на уровне
исходного кода. POSIX-совместимые оболочки разработаны на базе оболочки Корна.
Рассмотрим основные элементы программирования в оболочке bash. В других
оболочках большинство команд будет совпадать с описанными ниже.

**Переменные в языке программирования bash**

Командный процессор *bash* обеспечивает возможность использования переменных типа строка символов. Имена переменных могут быть выбраны пользователем.
Пользователь имеет возможность присвоить переменной значение некоторой строки символов. Например, команда
```
mark=/usr/andy/bin
```
присваивает значение строки символов ```/usr/andy/bin``` переменной mark типа строка символов.

Использование: 
```
mv afile ${mark}
```
переместит файл afile из текущего каталога в каталог с абсолютным полным именем /usr/andy/bin.

Использование значения, присвоенного некоторой переменной, называется *подстановкой*.

**Команды read и echo**

Команда read позволяет записать значение для переменной с клавиатуры. Она имеет следующий синтаксис:
```
read <variable>
```
Команда echo выводит текст на экран, если имеет вид:
```
echo "Some text"
```
В данном случае она выведет на экран *Some text*.

С помощью данной команды также можно вывести на экран содержимое, например, переменных:
```
echo <variable>
```

С прочей теорией и основами языка bash можно ознакомиться в материалах к *лабораторной работе №11*[[1]](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf).

Также в ходе выполнения заданий лабораторной работы я столкнулась в необходимости изучения дополнительных натериалов, а именно:

- архивирование файлов в Linux[[2]](https://losst.ru/arhivatsiya-v-linux)

- использование массивов в bash[[3]](https://losst.ru/massivy-bash)

- различные способы составления списка содержимого каталога без использования команды ls[[4]](https://itisgood.ru/2019/04/02/razlichnye-sposoby-sostavlenija-spiska-soderzhimogo-kataloga-bez-ispolzovanija-komandy-ls/)

- команда find в Linux[[5]](https://losst.ru/komanda-find-v-linux)

- команда wc в Linux[[6]](https://losst.ru/komanda-wc-v-linux)

---

### **Выполнение работы:**

**Задание 1.**

*Написать скрипт, который при запуске будет делать резервную копию самого себя (то есть файла, в котором содержится его исходный код) в другую директорию
backup в вашем домашнем каталоге. При этом файл должен архивироваться одним из архиваторов на выбор zip, bzip2 или tar. Способ использования команд
архивации необходимо узнать, изучив справку.*

Для этого сначала перейдем в домашний каталог (```cd```), после чего создадим наш командный файл, который будет называться ```arch.sh```, командой ```touch```. Далее в домашнем каталоге создадим каталог ```backup``` командой создания каталогов ```mkdir```, в нем мы будем создавать резервные копии и архивы с командными файлами (*рисунок 1*).

Чтобы понять структуру архивации файлов и создания архивов воспользуемся справкой ```man tar``` и изучим команду ```tar```, которая позволит нам создать архив (*рисунок 1*). Для создания командных файлов будем использовать текстовой редактор vi. Открываем с его помощью будущий командный файл arch.sh (```vi arch.sh```) (*рисунок 1*).

![](https://sun9-10.userapi.com/impg/E2hD-dD0BXwwdIL-4Cq-Gv_xsNhBquM9GEjyOQ/iK4yqRTW-TQ.jpg?size=733x171&quality=96&sign=c08c41523bf1756b94a5c5e715d6f796&type=album)

    рисунок 1: создание файла и каталога

Пишем сам командный файл. Для того, чтобы система распознавала его как командный, в первой строке прописываем ```#!/bin/bash``` (*рисунок 2*). 

Теперь о структуре кода. Создаем перменную ```name```, в которой будет содержаться имя данного командного файла (передаем его указателем ```$0```) ```name="$0"```. Далее командой ```cp``` перемещаем копируем файл в недавно созданный каталог ```~/backup```. Переходим в данный каталог. Вот теперь воспользуемся командой ```tar -cf```, которая позволит нам создать архив, имеющий такое название, какое имеет командный файл, но в формате .tar (```${name}.tar```). Ключ -cf позволяет нам создать архив и сразу же поместить в него нам командный файл, который мы передаем ссылкой ```${name}``` (*рисунок 2*). 

![](https://sun9-4.userapi.com/impg/MXGUVVArjxbmm3lvUyVeiHn-WaMNaaH2WGLIzw/w2GOQCJZt-U.jpg?size=603x232&quality=96&sign=8bd14dc4400d6fa1c29950c103ee7953&type=album)

    рисунок 2: создание командного файла

Переходим в командный режим редактора vi нажатием клавиши Esc и, нажав :, переходим в режим последней строки, по средствам которой мы записываем изменения в файл - ```w``` ,- и выходим из редактора - ```q``` (*рисунок 3*).

![](https://sun9-65.userapi.com/impg/F3xYU0cxmfcziogGHrpoSClt1b70KdW9FNGtVg/WJhRtI3Y_ac.jpg?size=609x229&quality=96&sign=f1fa32560de83f815f0416a52431b08f&type=album)

    рисунок 3: запись изменений и выход

Теперь протестируем созданный файл. Для того, чтобы запустить его как команду необходимо использовать ```bash``` (*рисунок 4*)

![](https://sun9-70.userapi.com/impg/kSO-ogDqHHV3dxlr5OETjz86ImqaCNhkUWNWFw/iWYoEB1ullY.jpg?size=595x51&quality=96&sign=7307b459967b6a6dcc9e0aee10a14788&type=album)

    рисунок 4: запуск командного файла

Проверим наш файл. Посмотрим на результат его работы - перейдем в каталог backup, в котором должен был создаться необходимый архив. Видим, что в нем действительно лежит копия исходного файла и создан новый архив (*рисунок 5*).

![](https://sun9-75.userapi.com/impg/Xgo3FJItKJRlgazfnDzl8Cdmctn0POvdyFHqJQ/KB-xI32x4Mg.jpg?size=436x206&quality=96&sign=2ee44a88b9e8fd70bc646d09107539f9&type=album)

    рисунок 5: проверка работы командного файла (1)

Теперь на всякий случай проверим созданный архив, открываем его и видим, что в нем находится все тот же командный файл arch.sh (*рисунок 6*).

![](https://sun9-37.userapi.com/impg/kSl8ozNNpUVmFsfgNVplLssNjCqifT0T0rytgw/Y-wnJK4qS0s.jpg?size=601x202&quality=96&sign=02968653c5a4319a7ecef1f726158c8f&type=album)

    рисунок 6: проверка работы командного файла (2)


**Задание 2.** 

*Написать пример командного файла, обрабатывающего любое произвольное
число аргументов командной строки, в том числе превышающее десять. Например, скрипт может последовательно распечатывать значения всех переданных
аргументов.*

Сперва создадим соответствующий командный файл ```numbers.sh``` и сразу откроем его в редакторе (*рисунок 7*).

![](https://sun9-41.userapi.com/impg/iUs19pnBKYilCkAUcYfMKwnqYkI90nvp-MGktQ/F8vaQBXkEQw.jpg?size=518x57&quality=96&sign=8e417dcdddc2f0dffedabd0bfbffdc9c&type=album)

    рисунок 7: создание файла numbers.sh

Для того, чтобы вводить неизвестное количество аргументов (даже большее десяти) и обрабатывать их, воспользуемся массивом, который назовем ```numbers```. Сначала объявим его: ```declare -a numbers```. С помощью команды ```echo``` выведем на экран сообщение о том, что нужно ввести элементы, притом в качестве разделителя использовать пробелы. Далее командой ```read -a``` считываем с клавиатуры элеменьы массива. Выводим строку *Your numbers* и выводим все элементы массива - ```echo ${numbers[@]}``` (@ - все элементы массива) (*рисунок 8*). 

![](https://sun9-5.userapi.com/impg/a0OtTNK3GsIrh_GEXrkC4hiPQZ-tAX8K85JYFg/jgHHvQ2X_yo.jpg?size=738x250&quality=96&sign=0cd8c15f4eaaa0bb7d6084c2e87853db&type=album)

    рисунок 8: набор текста файла, сохранение и выход

Проверим работу нашего файла. Видим, что он работает исправно и действительно выводит те числа, которые мы ввели (*рисунок 9*).

![](https://sun9-34.userapi.com/impg/8YbRLGjVDThKOdbfJ2PsvuvTARKdvs7GhU9Vqw/MlLsoPieEpI.jpg?size=686x129&quality=96&sign=680aad5b5e5c98d9981a4da632baec9d&type=album)

    рисунок 9: результат работы командного файла 

**Задание 3.** 

*Написать командный файл — аналог команды ls (без использования самой этой
команды и команды dir). Требуется, чтобы он выдавал информацию о нужном
каталоге и выводил информацию о возможностях доступа к файлам этого каталога.*

Сперва создадим соответствующий командный файл ```ls.sh``` и сразу откроем его в редакторе (*рисунок 10*).

![](https://sun9-30.userapi.com/impg/MzdEJsbLnBUOBTpUKmxFFKRf0nYx5dVBNuj-9g/tGvs66OxIUs.jpg?size=533x63&quality=96&sign=09cfe0820e84898798156124cadc339c&type=album)

    рисунок 10: создание файла ls.sh

Пишем текст командного файла. Сначала выведем сообщение о вводе имени каталога, который мы хотим рассмотреть, - ```echo```. Команда ```read``` позволит нам считать введенную с клавиатуры директорию в переменную name. Выводим имя директории и переходим в заданный каталог: ```cd ${name}```. Выведем строку-сообщение о выводе файлов каталога и прав доступа к ним командой вывода echo. Выведем содержимое текущего катлога командой ```stat```: ```stat -c '%A %n' *```. Где -с является ключом, который выведет наши файлы построчно, %A - вывод прав доступа в формате, читаемом для человека, а не машины, %n - названия файлов, * - указывает на текущий каталог (*рисунок 11*).

![](https://sun9-69.userapi.com/impg/EU5hcbTJ_swQSznZS8ttJzYlbs7E9-PwBl_LAQ/-DeboA08zLU.jpg?size=734x246&quality=96&sign=7a93791c7d4a8da67f955e42f6ac5ec6&type=album)

    рисунок 11: набор текста файла, сохранение и выход

Посмотри на резульаты работы нашего командного файла. Рассмотрим директорию, созданную в задании 1 (*рисунок 12*), и домашний катлог (*рисунок 13*). Видим, что файл работтает исправно, все, что требовалось, выполнили.

![](https://sun9-2.userapi.com/impg/k2_u8L-FfEOK9TzvwrpwJP814BoMlFLRKvNtGQ/dQ0HQuZcNy4.jpg?size=734x249&quality=96&sign=61856d1851bbda413983b0baa82739f1&type=album)

    рисунок 12: результат работы командного файла 

![](https://sun9-39.userapi.com/impg/YgZ-LMmr9SmUiO9ofhfPtlQ6pVQXVS5Svz4vCQ/R3osj7maGlk.jpg?size=463x597&quality=96&sign=11bd91d881bed9cd8b3d5e466801f82d&type=album)

    рисунок 13: результат работы командного файла 

**Задание 4.** 

*Написать командный файл, который получает в качестве аргумента командной
строки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет количество
таких файлов в указанной директории. Путь к директории также передаётся в
виде аргумента командной строки.*

Сперва создадим соответствующий командный файл ```find.sh``` и сразу откроем его в редакторе (*рисунок 14*).

![](https://sun9-12.userapi.com/impg/H_3Flwrj2dl64B82jmH2wEE0QWTNdmNXTgddWQ/ayf_sVp-WYM.jpg?size=777x74&quality=96&sign=6770b607911f0199df56f6b540320a5c&type=album)

    рисунок 14: создание файла find.sh

Напишем сам командный файл. Введем обозначения двух переменных: ```dirt```, в которую мы запишем рассматриваемую директорию, и ```format```, в которую запишем искомый формат файла. Им сопутсвуют два вывода echo, сообщающих пользователю о том, что именно необходимо ввести в данный момент. ```cd ${dirt}``` - переходим в требуемую директорию. Ищем (команда ```find```) в ней ("." - текущая директория) файлы по именам (```-name```), в которых встречается нам введенный формат. Конвейером считываем нереализованный вывод и командой ```wc -l``` считаем его строки, т.е. - файлы, найденные в данной директории и соответствующие требованиям. (*рисунок 15*)

![](https://sun9-52.userapi.com/impg/pp_RO0LChQjqWNxxgtz_21tzXDOicKaQ-4rE4w/bWb2vilxqj8.jpg?size=733x282&quality=96&sign=6c3844ba2e814f075a41caf0398a7e78&type=album)

    рисунок 15: ввод текста файла

Посмотрим на результат работы написанного файла. Введем с клавиатуры путь к домашней директории, будем искать в ней файлы формата txt, видим, что найдем 41 файл (*рисунок 16*). Проверить такое количество файлов проблематично, поэтому осуществим проверку, используя директорию australia. Откроем ее и запустим файл с теми же требованиями. В выводе найден один файл, соответствующий требованиям, смотрим на содержимое каталога, видим, что это действительно так (*рисунок 17*).

![](https://sun9-40.userapi.com/impg/gJ5qYyOM-ghFCRqfmMIXxdc6MhDHhTBhFVVp1w/MLIv7YTLVJk.jpg?size=718x165&quality=96&sign=98d8c73fa07454e18c5b0a3f8cb20577&type=album)

    рисунок 16: результат работы

![](https://sun9-75.userapi.com/impg/WiqyP5V4YrFfa9l3VB64FOn9J05lB5UnYo9kIg/ebDNcYFEkH0.jpg?size=537x456&quality=96&sign=ec215f3e70b2affcee5a42b8ef3e09f7&type=album)

    рисунок 17: результат работы

---

## **Вывод:**

Изучила основы программирования в оболочке ОС UNIX/Linux. Изучила основы языка bash, научилась писать небольшие командные файлы.

### **Библиография:**

[1] [Лабораторная работа №11](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

[2] [Архивирование файлов в Linux](https://losst.ru/arhivatsiya-v-linux)

[3] [Использование массивов в bash](https://losst.ru/massivy-bash)

[4] [Различные способы составления списка содержимого каталога без использования команды ls](https://itisgood.ru/2019/04/02/razlichnye-sposoby-sostavlenija-spiska-soderzhimogo-kataloga-bez-ispolzovanija-komandy-ls/)

[5] [Команда find в Linux](https://losst.ru/komanda-find-v-linux)

[6] [Команда wc в Linux](https://losst.ru/komanda-wc-v-linux)