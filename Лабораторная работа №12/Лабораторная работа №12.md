# **РОCСИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
## Факультет физико-математических и естественных наук 
## Кафедра прикладной информатики и теории вероятностей 

## ОТЧЕТ
## ПО ЛАБОРАТОРНОЙ РАБОТЕ № 12

### *дисциплина: Операционные системы*

Студент: Губина Ольга Вячеславовна 

Группа: НПИбд-01-20

Преподаватель: Велиева Татьяна Рефатовна

МОСКВА 

2021 г.

---

### **Цель работы:**

Изучить основы программирования в оболочке ОС UNIX/Linux. Научится писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.


### **Задачи:**

1. Научиться писать небольшие командные файлы с использованием логических управляющих конструкций и циклов;
2. Применить их на практике.

### **Теоретическое введение:**

В данной лабораторной работе нам предстоит научиться писать командные файлы и использовать их на практике. Для этого нам необходимо ознакимиться с некоторой теорией. 

**Командные процессоры (оболочки)**

*Командный процессор* (командная оболочка, интерпретатор команд shell) —
это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. 

В операционных системах типа UNIX/Linux наиболее часто
используются следующие реализации командных оболочек:

- оболочка Борна (Bourne shell или sh) — стандартная командная оболочка
UNIX/Linux, содержащая базовый, но при этом полный набор функций;

- С-оболочка (или csh) — надстройка на оболочкой Борна, использующая Сподобный синтаксис команд с возможностью сохранения истории выполнения
команд;

- оболочка Корна (или ksh) — напоминает оболочку С, но операторы управления
программой совместимы с операторами оболочки Борна;

- BASH — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software
Foundation).

*POSIX* (Portable Operating System Interface for Computer Environments) — набор
стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ.

Стандарты POSIX разработаны комитетом IEEE (Institute of Electrical and
Electronics Engineers) для обеспечения совместимости различных UNIX/Linuxподобных операционных систем и переносимости прикладных программ на уровне
исходного кода. POSIX-совместимые оболочки разработаны на базе оболочки Корна.
Рассмотрим основные элементы программирования в оболочке bash. В других
оболочках большинство команд будет совпадать с описанными ниже.

**Переменные в языке программирования bash**

Командный процессор *bash* обеспечивает возможность использования переменных типа строка символов. Имена переменных могут быть выбраны пользователем.
Пользователь имеет возможность присвоить переменной значение некоторой строки символов. Например, команда
```
mark=/usr/andy/bin
```
присваивает значение строки символов ```/usr/andy/bin``` переменной mark типа строка символов.

Использование: 
```
mv afile ${mark}
```
переместит файл afile из текущего каталога в каталог с абсолютным полным именем /usr/andy/bin.

Использование значения, присвоенного некоторой переменной, называется *подстановкой*.

**Команды read и echo**

Команда read позволяет записать значение для переменной с клавиатуры. Она имеет следующий синтаксис:
```
read <variable>
```
Команда echo выводит текст на экран, если имеет вид:
```
echo "Some text"
```
В данном случае она выведет на экран *Some text*.

С помощью данной команды также можно вывести на экран содержимое, например, переменных:
```
echo <variable>
```

С прочей теорией и основами языка bash можно ознакомиться в материалах к *лабораторной работе №11*[[1]](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf).

Также в ходе выполнения заданий лабораторной работы я столкнулась в необходимости изучения дополнительных натериалов, а именно:

- архивирование файлов в Linux[[2]](https://losst.ru/arhivatsiya-v-linux)

- команда find в Linux[[3]](https://losst.ru/komanda-find-v-linux)

- циклы if[[4]](https://habr.com/ru/company/ruvds/blog/325928/)

- команда xargs[[5]](https://blog.sedicomm.com/2018/11/21/12-prakticheskih-primerov-komandy-xargs-dlya-nachinayushhih-v-linux/)

---

### **Выполнение работы:**

***Задание 1***

*Используя команды getopts grep, написать командный файл, который анализирует командную строку с ключами:*

- *-iinputfile — прочитать данные из указанного файла;*
- *-ooutputfile — вывести данные в указанный файл;*
- *-pшаблон — указать шаблон для поиска;*
- *-C — различать большие и малые буквы;*
- *-n — выдавать номера строк.*

*а затем ищет в указанном файле нужные строки, определяемые ключом -p*

Создадим и откроем командой ```vi``` командный файл get.sh, который будет анализировать командную строку по предложенным в задании ключам (*риснуок 1*).

![](https://sun9-60.userapi.com/impg/QcUfVFjkj7WZEzRBCvWkndMPgc_rlRMDf3kX8g/f2elgW9fD70.jpg?size=380x41&quality=96&sign=3364f8cb4a75e1028bdd61197d773878&type=album)

    рисунко 1:

Напишем код для командного файла (*рисунок 2*). Используем пример использования оператора getopts из материалов к лабораторной работе №11, а также циклы ```if```, которые будут помогать распознать, какие именно действия нам нужно выполнить в зависимости от упоминания ключей ```-C``` и ```-n```.

![](https://sun9-13.userapi.com/impg/sDMxdUrfd4e5Nn9eJw1k5WGJSexrQWh9BqPXgg/finK5Bkjeaw.jpg?size=732x554&quality=96&sign=e20dd077401d041ba4ea16bb642575ca&type=album)

    рисунок 2:

Создали файл input.txt, из которого будем читать информацию. В него запишем три одинаковых строчки, отличных только прописными и строчными буквами (*риснуок 3*).

![](https://sun9-18.userapi.com/impg/cJ60dHPdOZRy4y_QpFOauLuiRCtOU6ysFNh5zQ/6OUnk6N-gPo.jpg?size=555x156&quality=96&sign=8e214d0fd5d757bae88db6dab6aab426&type=album)

    рисунок 3:

Вызываем наш командный файл в качестве команды, в качестве файла для чтения выбираем файл input.txt, для записи - output.txt, параметр поиска - слово "hello". Сразу проверим работу командного файла, обозначив обе опции ```-C``` и ```-n```. Проосматриваем файл output.txt с помощью команды ```cat```. Видим, что программа работает исправно (*рисунок 4*).

![](https://sun9-4.userapi.com/impg/DLx9e6EYGNSE9dHTUCIm70KciKVF12WWsuPJhQ/TP4ZD2y8CgA.jpg?size=696x158&quality=96&sign=5837a2d072b6e068575f9929db49f9ef&type=album)

    рисунок 4:


***Задание 2***

*Написать на языке Си программу, которая вводит число и определяет, является
ли оно больше нуля, меньше нуля или равно нулю. Затем программа завершается
с помощью функции exit(n), передавая информацию в о коде завершения в
оболочку. Командный файл должен вызывать эту программу и, проанализировав
с помощью команды $?, выдать сообщение о том, какое число было введено.*

Создадим и откроем с помощью редактора ```vi``` два файла, которые нам пригодятся для этого задания, ```prog.cpp``` - файл с программой на языке С, ```k.sh``` - командный файл, который вызовет на выполнение файл с кодом и проанализирует введенное в него число (*рисунок 5*).

![](https://sun9-42.userapi.com/impg/wMu5HNIxJ_LYZ_9wkbg4czw1CDfHx5TaZRFWRA/LI--v96odJc.jpg?size=414x39&quality=96&sign=c9d9ae7c225762d24bb106326f3a37f6&type=album)

    рисунок 5:

Рассмотрим код файла ```prog.cpp``` (*рисунок 6*). Здесь все стандартно, по канонам программ на C. Вводим число с клавиатуры, сравниваем его значение с нулем и выводим соответсвующее сообщение на экран (число больше, меньше нуля или равно ему). Завершаем программу с помощью функции exit(n), передавая информацию в о коде завершения в оболочку 

![](https://sun9-19.userapi.com/impg/Psdjx1EtKuRn4aLe0W3CBtWvNs-5ljUgWnNH3g/NKKgVrgqSJY.jpg?size=730x501&quality=96&sign=0b1b40a4ae6fc116ca4fcd00db766d89&type=album)

    рисунок 6:

Теперь перейдем к самому командному файлу (*рисунок 7*). В нем мы сначала компилируем наш код (2 строка), вызываем программу на выполнение (./prog), в конце анализируем и передаем на экран с помощью ```echo $?```, какое число было введено для сравнения с нулем.

![](https://sun9-5.userapi.com/impg/KsvKu1_0wQfp5x_O3Se4e93UE3O3MIVFlVoFnQ/gUht9mDe20k.jpg?size=504x166&quality=96&sign=88c69ba6a4646159bf7a7d18c7c70214&type=album)

    рисунок 7:

Проверим работу файлов (*рисунок 8*). Вызовем командный файл ```k.sh```. в первом случае введем число 5, видим, что система вывела сообщение о том, что оно больше нуля, и после данной процедуры можно наблюдать результат работы командного файла - вывод числа, которое мы ввели. То же происходит если на ввод подается 0.

![](https://sun9-75.userapi.com/impg/QfA4h7hznml9sGnymxMCSLVW30XfrOFBjbKTxw/oj_rjZp02PI.jpg?size=544x265&quality=96&sign=108ed2bd4348a24310eeae9f54962a8d&type=album)

    рисунок 8:


***Задание 3***

*Написать командный файл, создающий указанное число файлов, пронумерованных последовательно от 1 до N (например 1.tmp, 2.tmp, 3.tmp,4.tmp и т.д.).
Число файлов, которые необходимо создать, передаётся в аргументы командной
строки. Этот же командный файл должен уметь удалять все созданные им файлы
(если они существуют).*

Создадим и откроем с помощью редактора ```vi``` командный файл ```files.sh```, который будет создавать необходимое число файлов и удалять их. Напишем сам код (*рисунок 9*). Сперва ввод с клавиатуры числа файлов. Дальше входим в первый цикл ```for``` для i от 1 до n, в котором для кождого i создаем файл командой ```touch```, названием которого будет являться цифра, соответствующая значению i. Выводим на экран содержимое текущего каталога, чтобы убедиться, что файлы созданы. Спрашиваем, нужно ли удалить созданные файлы, если ответ да, то снова входим в цикл, только на этот раз не создаем файлы, а удаляем, и вновь проверяем содержимое каталога.

![](https://sun9-2.userapi.com/impg/_rvdQHOsPwFCqNN9PalyItAmp-chkgsRpJbugQ/wJ2Whb2hEl8.jpg?size=699x491&quality=96&sign=47ea787585471c9eecab676b3647a953&type=album)

    рисунок 9:

Проверим работу командного файла (*рисунок 10*). в качесвте числа на ввод подадим число 2. По выводам команды видим, что два соответствующих файла сначала были созданы, а потом удалены, поскольку мы согласились на их удаление, введа согласие - ```y```.

![](https://sun9-43.userapi.com/impg/GIGJ5BgMuOfAMNt8Bi2qr55iXk0QXj8uMnEANA/sQP-fjo5ViQ.jpg?size=715x435&quality=96&sign=b48689b51fc475e03ba27331f5a6d2f3&type=album)

    рисунок 10:


***Задание 4***

*Написать командный файл, который с помощью команды tar запаковывает в
архив все файлы в указанной директории. Модифицировать его так, чтобы запаковывались только те файлы, которые были изменены менее недели тому назад
(использовать команду find).*

Напишем командный файл ```tar.sh```, который будет архивировать все файлы директории, отредактированные не позднее чем 7 дней назад (*рисунок 11*). Для этого сначала будем вводить ди ректорию, в которой будем работать, и имя будущего массива с клавиатуры, для этого в коде используем команду ```read```. Когда обе переменные обозначены, воспользуемся командой ```find```, которая поможет нам найти подходящие нам файлы. В ней мы использовали следуюзие опции:

- ```.``` - поиск осуществляется в текущем каталоге
- ```-mtime -7``` - файлы, редактированные не позднее чем 7 дней назад
- ```-type f``` - поиск именно файлов, без каталогов (папок)
- ```-print0``` - позволяет выводить полный путь к файлу на стандартном выходе, за которым следует нулевой символ

Далее используем конвейер и создаем архив с заданным с клавиатуры именем при помощи команды ```tar``` (*риснуок 11*). ```xarg``` - флаг -0 xargs эффективно использует пространство в именах файлов, поэтому мы его используем для того, чтобы закинуть все найденные файлы в архив. Ключи ```-cvzf``` позволят:

- ```-c``` - создать архив в linux
- ```-v``` - показать подробную информацию о процессе работы
- ```-z``` - сжать архив с помощью Gzip
- ```-f``` - обозначить файлы для записи архива

После выводим на экран содержимое заданной директории командой ```ls```, чтобы удостовериться. что архив был создан.

![](https://sun9-7.userapi.com/impg/uTwkySrlwNwTpwtHPXAQ_TuzT4EAAdZgGHN-ug/R5p7-4M2Q6U.jpg?size=777x300&quality=96&sign=ddd79e94a1350aadd352dc0a50735c69&type=album)

    рисунок 11:

Выовем наш файл на проверку (*рисунок 12*). В качестве директории для работы обозначим директорию ```new_directory```, в которую предварительно были помещены: 2 старых файла с прошлых лабораторных работ (abc1, feathers) и файл отредактированный в день выполнения работы - text.txt. В кажестве имени архива задаем число выполнения лр. Видим, что сначала система выводит на экран файл, который удовлетворяет нашим условиям, и это действительно соответствует действительности. После он показывает нам содержимое заданной директории. Видим, что архив был успешно создан.

![](https://sun9-1.userapi.com/impg/ODGQRHuaMCGclH6spB-QjyAZpKwKTlUTFeXraA/v0e_Yq3BEvY.jpg?size=572x169&quality=96&sign=78cbc1a016462053082f1bf297eca887&type=album)

    рисунок 12:

Теперь проверим директорию на анличие архива. Видим, что он на месте (*рисунок 13*).

![](https://sun9-55.userapi.com/impg/ZTvwwESrPSQkFMEHNXlS5U7mCl3qHAfqW9aCjQ/mdvhN8pYk-s.jpg?size=935x415&quality=96&sign=271a69e688db716d83de69ae049cc259&type=album)

    рисунок 13:

Откроем сам архив. Видим, что в нем действительно содержится файл text.txt, удовлетворяющий нашим условиям (*рисунок 14*).

![](https://sun9-6.userapi.com/impg/pTKks1FkobAnkUDl2XGOObfc2zQodAeWH55gZQ/nhV380SUMyo.jpg?size=1142x334&quality=96&sign=aadb35c847deeaa0af7f968d1ae2ec33&type=album)

    рисунок 14:


---

## **Вывод:**

Изучила основы программирования в оболочке ОС UNIX/Linux. Научилась писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.


### **Библиография:**

[1] [Лабораторная работа №11](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

[2] [Архивирование файлов в Linux](https://losst.ru/arhivatsiya-v-linux)

[3] [Команда find в Linux](https://losst.ru/komanda-find-v-linux)

[4] [Циклы if](https://habr.com/ru/company/ruvds/blog/325928/)

[5] [Команда xargs](https://blog.sedicomm.com/2018/11/21/12-prakticheskih-primerov-komandy-xargs-dlya-nachinayushhih-v-linux/)